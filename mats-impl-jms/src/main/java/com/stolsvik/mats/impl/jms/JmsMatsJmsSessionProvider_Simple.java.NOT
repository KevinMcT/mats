package com.stolsvik.mats.impl.jms;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.IdentityHashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import javax.jms.Connection;
import javax.jms.JMSException;
import javax.jms.Session;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.stolsvik.mats.exceptions.MatsBackendException;

public class JmsMatsJmsSessionProvider_Simple implements JmsMatsJmsSessionProvider {

    private static final Logger log = LoggerFactory.getLogger(JmsMatsJmsSessionProvider_Simple.class);

    private final JmsConnectionSupplier _jmsConnectionSupplier;

    public JmsMatsJmsSessionProvider_Simple(JmsConnectionSupplier jmsConnectionSupplier) {
        _jmsConnectionSupplier = jmsConnectionSupplier;
    }

    @Override
    public JmsMatsJmsSessionContext getJmsMatsSessionContext(JmsMatsTxContextKey txContextKey) {
        return new JmsSessionContextConnectionSharer().getJmsSessionContext(txContextKey);
    }

    /**
     * Common object for all {@link JmsSessionContextImpl}s that share a JMS Connection.
     */
    private class JmsSessionContextConnectionSharer {
        private volatile Connection _currentJmsConnectionShared;

        private IdentityHashMap<Connection, JmsSessionContextImpl> _jmsConnectionsInPlay = new IdentityHashMap<>();

        private JmsSessionContextImpl getJmsSessionContext(JmsMatsTxContextKey txContextKey) {
            return new JmsSessionContextImpl(txContextKey);
        }

        /**
         * Impl of {@link JmsMatsJmsSessionContext}.
         */
        private class JmsSessionContextImpl implements JmsMatsJmsSessionContext {
            private final JmsMatsTxContextKey _txContextKey;

            public JmsSessionContextImpl(JmsMatsTxContextKey txContextKey) {
                _txContextKey = txContextKey;
            }

            private final ArrayDeque<JmsSessionHolderImpl> _sessionCache = new ArrayDeque<>(1);
            private final Set<JmsSessionHolderImpl> _sessionInUse = new HashSet<>();

            @Override
            public JmsMatsJmsSessionHolder leaseTransactionalSession() throws JMSException {
                // :: Create the JMS Connection if it is not present.
                // Double-checked locking idiom - working version..!
                synchronized (JmsSessionContextConnectionSharer.this) {
                    if (_currentJmsConnectionShared == null) {
                        _currentJmsConnectionShared = _jmsConnectionSupplier.createJmsConnection(_txContextKey);
                    }
                }

                JmsSessionHolderImpl jmsSessionHolder;

                // :: Check if we have a session available
                synchronized (_sessionCache) {
                    jmsSessionHolder = _sessionCache.pollFirst();
                }

                // ?: Did we have one available?
                if (jmsSessionHolder == null) {
                    // -> No, no session available, make a new
                    // Can throw JMS Exception.
                    Session jmsSession = _currentJmsConnectionShared.createSession(true, Session.SESSION_TRANSACTED);
                    jmsSessionHolder = new JmsSessionHolderImpl(_currentJmsConnectionShared, jmsSession);
                }

                // :: Insert it into the "in use" set.
                synchronized (_sessionInUse) {
                    _sessionInUse.add(jmsSessionHolder);
                }

                return jmsSessionHolder;
            }

            @Override
            public void closeAllSessionsInPool() {
                List<JmsSessionHolderImpl> toClose = new ArrayList<>();
                synchronized (_sessionCache) {
                    toClose.addAll(_sessionCache);
                }
                JmsSessionHolderImpl sessionHolder = null;
                try {
                    for (Iterator<JmsSessionHolderImpl> iter = toClose.iterator(); iter.hasNext();) {
                        sessionHolder = iter.next();
                        sessionHolder._jmsSession.close();
                    }
                }
                catch (Throwable t) {
                    log.warn("Got " + t.getClass().getSimpleName() + " when trying to close JMS Session ["
                            + sessionHolder._jmsSession + "]. Closing the underlying JMS Connection,"
                            + " thus closing all Sessions from it.", t);
                    // TODO: Close Connection.
                }
            }

            private class JmsSessionHolderImpl implements JmsMatsJmsSessionHolder {

                private final Connection _jmsConnection;
                private final Session _jmsSession;

                public JmsSessionHolderImpl(Connection jmsConnection, Session jmsSession) {
                    _jmsConnection = jmsConnection;
                    _jmsSession = jmsSession;
                }

                @Override
                public void isConnectionLive(boolean tryHard) throws MatsBackendException {
                    JmsMatsActiveMQSpecifics.isConnectionLive(_jmsConnection);
                }

                @Override
                public Session getSession() {
                    return _jmsSession;
                }

                @Override
                public void releaseSession() {
                    log.info("Releasing/enpooling SessionHolder ["+this+"].");
                    synchronized (_sessionCache) {
                        _sessionCache.addFirst(this);
                        synchronized (_sessionInUse) {
                            _sessionInUse.remove(this);
                        }
                    }
                }

                @Override
                public void closeSession() {
                    synchronized (_sessionInUse) {
                        _sessionInUse.remove(this);
                    }
                    try {
                        _jmsSession.close();
                    }
                    catch (Throwable t) {
                        log.warn("Got " + t.getClass().getSimpleName() + " when trying to close JMS Session ["
                                + _jmsSession + "]. Closing the underlying JMS Connection,"
                                + " thus closing all Sessions from it.", t);
                        closeConnection();
                    }
                }

                @Override
                public void sessionCrashed(Throwable t) {
                    log.warn("JMS Session came back 'crashed' - Closing the underlying JMS Connection,"
                            + " thus closing all Sessions from it. [" + t.getClass().getSimpleName() + ": "
                            + t.getMessage() + "]");
                    closeConnection();
                }

                private void closeConnection() {
                    try {
                        _jmsConnection.close();
                    }
                    catch (Throwable t) {
                        log.warn("Got " + t.getClass().getSimpleName() + " when trying to close JMS Connection ["
                                + _jmsConnection + "]. Closing the underlying JMS Connection,"
                                + " thus closing all Sessions from it.", t);
                    }
                }
            }
        }
    }
}
